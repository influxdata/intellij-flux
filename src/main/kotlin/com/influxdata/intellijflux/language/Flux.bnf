{
    parserClass="com.influxdata.intellijflux.language.parser.FluxParser"
    parserUtilClass="com.influxdata.intellijflux.language.FluxParserUtil"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Flux"
    psiImplClassSuffix="Impl"
    psiPackage="com.influxdata.intellijflux.language.psi"
    psiImplPackage="com.influxdata.intellijflux.language.psi.impl"

    elementTypeHolderClass="com.influxdata.intellijflux.language.psi.FluxTypes"
    elementTypeClass="com.influxdata.intellijflux.language.psi.FluxElementType"
    tokenTypeClass="com.influxdata.intellijflux.language.psi.FluxTokenType"

    tokens=[
        comment='regexp://.*(\n)?'
        space='regexp:(\s|\n)+'
        COL=':'
        SEMI=';'
        EQ='='
        LP='('
        RP=')'
        LB='{'
        RB='}'
        DOT='.'
        ARROW="=>"
        PIPE_FORWARD="|>"

        // FIXME: less detailed than the flux spec. Just looks for anything falling between two unescaped double quotes.
        string_lit='regexp:"([^"\\]|\\.)*"'
        // FIXME: less detailed than the flux spec. Just looks for anything falling between two unescaped slashes.
        regex_lit='regexp:/([^/\\]|\\.)*/'
        unicode_digit="regexp:\p{N}"
        letter="regexp:(\p{L}|_)"

        plus_op='+'
        minus_op='-'
        mult_op='*'
        div_op='/'
        bang_op='!'
    ]
//    name(".*_op")='operartor'
    name(".*Expr")='expression'
    extends(".*Expr")=Expression
}

root ::= root_item *

private external EOF ::= <<eof>>
// token_sep is a workaround for handling comments that appear inside other
// larger structures.
// Ex: comments at the end of a line inside a line-separated parameter list or
// record fields.
private token_sep ::= (space | comment)+

private root_item ::=
    !EOF
    token_sep
    | option
    | Expression

identifier ::= letter (letter | unicode_digit)*
// Specifically targeting `pkg.ident` use cases... not arbitrary member expressions.
qualified_ident ::= identifier token_sep? DOT token_sep? (identifier | qualified_ident) {extends=identifier}

decimal_digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

private nonzero_decimal_digit ::= !"0" decimal_digit
int_lit ::= "0" | nonzero_decimal_digit decimal_digit*

float_lit ::= decimals DOT decimals? | DOT decimals
decimals ::= decimal_digit+


duration_lit  ::= (duration_magnitude duration_unit)+
duration_magnitude ::= decimal_digit+
duration_unit ::= "y" | "mo" | "w" | "d" | "h" | "m" | "s" | "ms" | "us" | "Âµs" | "ns"


date_time_lit ::= date [ "T" time ]
date ::= year_lit "-" month "-" day
year_lit ::= decimal_digit decimal_digit decimal_digit decimal_digit
month ::= decimal_digit decimal_digit
day ::= decimal_digit decimal_digit
time ::= hour ":" minute ":" second [ fractional_second ] [ time_offset ]
hour ::= decimal_digit decimal_digit
minute ::= decimal_digit decimal_digit
second ::= decimal_digit decimal_digit
fractional_second ::= "."  decimal_digit+
time_offset ::= "Z" | ("+" | "-") hour ":" minute

option ::= "option" token_sep? AssignmentExpr

Expression ::=
    AssignmentExpr
    | FuncExpr
    | CallExpr
    | CompositeExpr
    | LiteralExpr
    | IdentExpr
    | PipeExpr

LiteralExpr ::=
    float_lit
    | date_time_lit
    | duration_lit
    | int_lit
    | string_lit
    | regex_lit


// TODO: Label?
IdentExpr ::= qualified_ident | identifier
CallExpr ::= identifier token_sep? LP token_sep? [param_list] token_sep? RP
param_list ::= identifier token_sep? COL token_sep? Expression token_sep? ["," token_sep? param_list?]
FuncExpr ::= LP token_sep? param_list? RP token_sep? ARROW token_sep? fn_body
fn_body ::= Expression // FIXME: needs to model blocks, parens, the `return` kw....
// XXX: should the LHS be an IdentExpr?
AssignmentExpr ::= IdentExpr token_sep? EQ token_sep? Expression

CompositeExpr ::= record_lit
record_lit ::= LB token_sep? param_list token_sep? RB

// a |> b |> c ...
PipeExpr ::=
    Expression
    token_sep?
    PIPE_FORWARD
    token_sep?
    Expression {rightAssociative=true}
